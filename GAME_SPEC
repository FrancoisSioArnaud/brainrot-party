Glossaire

01-domain.md
Glossaire + concepts (Room, Sender, Player, Round, Item, Claim, Vote, Score, phases).

02-state-machine.md
Machine d’états serveur (lobby → game → over) + transitions autorisées + erreurs.

03-ws-protocol.md
Tous les messages WebSocket (ce fichier TS qu’on a fait) + invariants + exemples.

04-redis-schema.md
Clés Redis + JSON exact + TTL + opérations par message.

05-sequence-diagrams.md
Diagrammes (Mermaid) lobby + game + resync + room close.

06-frontend-master.md
Pages Master (Lobby, Game) : états UI, events envoyés, handlers reçus.

07-frontend-play.md
Pages Play (Enter/Choose/Wait/Game) : états UI, events, handlers.






01-domain.md
Glossaire + concepts (Room, Sender, Player, Round, Item, Claim, Vote, Score, phases).

02-state-machine.md
Machine d’états serveur (lobby → game → over) + transitions autorisées + erreurs.

03-ws-protocol.md
// ws/messages.ts
// Brainrot Party — WS message schema (Redis-only, TTL 12h, no DB)
//
// Constraints (as agreed):
// - device_id only (no session_id)
// - no thumb_url
// - no item partial: each Reel (URL) appears once per round/item; multi-sender uses k>1 in a single vote
// - server authoritative for claims/votes/scores/progression
// - master orchestrates reveal visuals (server sends VOTE_RESULTS; master animates; then END_ITEM)
//
// Note: This file only defines message payload types (no implementation).

/* ---------------------------------- */
/* Shared primitives                   */
/* ---------------------------------- */

export type RoomCode = string;
export type DeviceId = string;

export type PlayerId = string;
export type SenderId = string;
export type RoundId = string;
export type ItemId = string;
export type ReelId = string;

export type Phase = "lobby" | "game" | "over";
export type PlayerStatus = "free" | "taken" | "disabled";

/* ---------------------------------- */
/* Public models sent to clients       */
/* ---------------------------------- */

export interface PlayerPublic {
  player_id: PlayerId;
  sender_id: SenderId;
  is_sender_bound: boolean;
  active: boolean;
  status: PlayerStatus; // server-derived from (active + claims)
  name: string;
  avatar_url: string | null;
}

export interface SenderPublic {
  sender_id: SenderId;
  name: string;
  active: boolean;
  reels_count: number;
}

export interface ReelPublic {
  reel_id: ReelId;
  url: string;
}

/** What Play clients can select during voting (active senders only). */
export interface SenderSelectable {
  sender_id: SenderId;
  name: string;
}

/* ---------------------------------- */
/* Envelope                            */
/* ---------------------------------- */

export interface WsEnvelope<TType extends string, TPayload> {
  type: TType;
  payload: TPayload;
}

/* ---------------------------------- */
/* Client -> Server (Master)           */
/* ---------------------------------- */

export interface CreateRoomReq {
  // Prepared locally in Setup.
  senders: Array<{
    sender_id: SenderId;
    name: string;
    active: boolean;
    reels_count: number;
  }>;

  // Prepared locally in Setup: rounds + items + true_sender_ids.
  rounds: Array<{
    round_id: RoundId;
    items: Array<{
      item_id: ItemId;
      reel: {
        reel_id: ReelId;
        url: string;
      };
      true_sender_ids: SenderId[]; // never sent to Play before VOTE_RESULTS
    }>;
  }>;

  // If omitted, server uses rounds[].round_id order as provided.
  round_order?: RoundId[];
}
export type CreateRoomMsg = WsEnvelope<"CREATE_ROOM", CreateRoomReq>;

export interface TogglePlayerReq {
  code: RoomCode;
  player_id: PlayerId;
  active: boolean;
}
export type TogglePlayerMsg = WsEnvelope<"TOGGLE_PLAYER", TogglePlayerReq>;

export interface StartGameReq {
  code: RoomCode;
}
export type StartGameMsg = WsEnvelope<"START_GAME", StartGameReq>;

export interface ReelOpenedReq {
  code: RoomCode;
  round_id: RoundId;
  item_id: ItemId;
}
export type ReelOpenedMsg = WsEnvelope<"REEL_OPENED", ReelOpenedReq>;

export interface EndItemReq {
  code: RoomCode;
  round_id: RoundId;
  item_id: ItemId;
}
export type EndItemMsg = WsEnvelope<"END_ITEM", EndItemReq>;

export interface StartNextRoundReq {
  code: RoomCode;
}
export type StartNextRoundMsg = WsEnvelope<"START_NEXT_ROUND", StartNextRoundReq>;

export interface RoomClosedReq {
  code: RoomCode;
}
export type RoomClosedMsg = WsEnvelope<"ROOM_CLOSED", RoomClosedReq>;

/* ---------------------------------- */
/* Client -> Server (Play)             */
/* ---------------------------------- */

export interface JoinRoomReq {
  code: RoomCode;
  device_id: DeviceId;
}
export type JoinRoomMsg = WsEnvelope<"JOIN_ROOM", JoinRoomReq>;

export interface TakePlayerReq {
  code: RoomCode;
  player_id: PlayerId;
  device_id: DeviceId;
}
export type TakePlayerMsg = WsEnvelope<"TAKE_PLAYER", TakePlayerReq>;

export interface RenamePlayerReq {
  code: RoomCode;
  player_id: PlayerId;
  device_id: DeviceId;
  new_name: string;
}
export type RenamePlayerMsg = WsEnvelope<"RENAME_PLAYER", RenamePlayerReq>;

export interface UpdateAvatarReq {
  code: RoomCode;
  player_id: PlayerId;
  device_id: DeviceId;
  /** base64 or data URL; server normalizes to 400x400 and stores externally; Redis stores avatar_url only */
  image: string;
}
export type UpdateAvatarMsg = WsEnvelope<"UPDATE_AVATAR", UpdateAvatarReq>;

/* ---------------------------------- */
/* Client -> Server (Game / Play)      */
/* ---------------------------------- */

export interface SubmitVoteReq {
  code: RoomCode;
  round_id: RoundId;
  item_id: ItemId;
  player_id: PlayerId;
  device_id: DeviceId;
  selections: SenderId[]; // server enforces <= k (and can enforce == k)
}
export type SubmitVoteMsg = WsEnvelope<"SUBMIT_VOTE", SubmitVoteReq>;

/* ---------------------------------- */
/* Client -> Server (Resync)           */
/* ---------------------------------- */

export interface StateSyncReq {
  code: RoomCode;
  device_id: DeviceId;
}
export type StateSyncMsg = WsEnvelope<"STATE_SYNC", StateSyncReq>;

/* ---------------------------------- */
/* Server -> Client responses / pushes */
/* ---------------------------------- */

export interface RoomCreatedRes {
  code: RoomCode;
  phase: Phase; // "lobby"
  players: PlayerPublic[];
  senders: SenderPublic[];
}
export type RoomCreatedMsg = WsEnvelope<"ROOM_CREATED", RoomCreatedRes>;

export interface JoinOkRes {
  code: RoomCode;
  phase: Phase; // "lobby" or "game" or "over"
  players_visible: PlayerPublic[]; // visible to Play: active-only; status derived
}
export type JoinOkMsg = WsEnvelope<"JOIN_OK", JoinOkRes>;

export interface ErrorRes {
  code?: RoomCode;
  error:
    | "room_not_found"
    | "room_expired"
    | "bad_request"
    | "forbidden"
    | "conflict"
    | "not_in_phase"
    | "not_claimed";
  message?: string;
  details?: Record<string, unknown>;
}
export type ErrorMsg = WsEnvelope<"ERROR", ErrorRes>;

export interface TakePlayerOkRes {
  code: RoomCode;
  player_id: PlayerId;
}
export type TakePlayerOkMsg = WsEnvelope<"TAKE_PLAYER_OK", TakePlayerOkRes>;

export interface TakePlayerFailRes {
  code: RoomCode;
  player_id: PlayerId;
  reason: "taken_now" | "disabled" | "inactive";
}
export type TakePlayerFailMsg = WsEnvelope<"TAKE_PLAYER_FAIL", TakePlayerFailRes>;

/** Broadcast any time player state changes (claim, rename, avatar, toggle). */
export interface PlayerUpdateRes {
  code: RoomCode;
  player: PlayerPublic;
  sender_updated?: SenderPublic; // present when sender-bound rename happens
}
export type PlayerUpdateMsg = WsEnvelope<"PLAYER_UPDATE", PlayerUpdateRes>;

export interface SlotInvalidatedRes {
  code: RoomCode;
  player_id: PlayerId;
  reason: "disabled_or_deleted";
}
export type SlotInvalidatedMsg = WsEnvelope<"SLOT_INVALIDATED", SlotInvalidatedRes>;

export interface GameStartRes {
  code: RoomCode;
}
export type GameStartMsg = WsEnvelope<"GAME_START", GameStartRes>;

/* ---------------------------------- */
/* Game: Item + Vote                   */
/* ---------------------------------- */

export interface NewItemRes {
  code: RoomCode;
  round_id: RoundId;
  item_index: number;
  item_id: ItemId;

  reel: ReelPublic;

  // multi-slot count
  k: number;

  // grid on Play
  senders_selectable: SenderSelectable[];

  // for Master UI convenience (equals k)
  slots_total: number;
}
export type NewItemMsg = WsEnvelope<"NEW_ITEM", NewItemRes>;

export interface StartVoteRes {
  code: RoomCode;
  round_id: RoundId;
  item_id: ItemId;
  k: number;
  senders_selectable: SenderSelectable[];
}
export type StartVoteMsg = WsEnvelope<"START_VOTE", StartVoteRes>;

export interface VoteAckRes {
  code: RoomCode;
  round_id: RoundId;
  item_id: ItemId;
  accepted: boolean;
  reason?: "invalid_selection" | "late" | "too_many" | "not_in_vote" | "not_claimed";
}
export type VoteAckMsg = WsEnvelope<"VOTE_ACK", VoteAckRes>;

export interface PlayerVotedRes {
  code: RoomCode;
  round_id: RoundId;
  item_id: ItemId;
  player_id: PlayerId;
}
export type PlayerVotedMsg = WsEnvelope<"PLAYER_VOTED", PlayerVotedRes>;

/* ---------------------------------- */
/* Results (Master only)               */
/* ---------------------------------- */

export interface VoteResultPerPlayer {
  player_id: PlayerId;
  selections: SenderId[];
  correct: SenderId[];
  incorrect: SenderId[];
  points_gained: number;
  score_total: number; // after applying points_gained
}

export interface VoteResultsRes {
  code: RoomCode;
  round_id: RoundId;
  item_id: ItemId;
  true_senders: SenderId[];
  players: VoteResultPerPlayer[];
}
export type VoteResultsMsg = WsEnvelope<"VOTE_RESULTS", VoteResultsRes>;

/* ---------------------------------- */
/* Round recap (Master) + Round end    */
/* ---------------------------------- */

export interface RoundRecapPerPlayer {
  player_id: PlayerId;
  points_round: number; // delta for this round only
  score_total: number; // cumulative total after round
}

export interface RoundRecapRes {
  code: RoomCode;
  round_id: RoundId;
  players: RoundRecapPerPlayer[];
}
export type RoundRecapMsg = WsEnvelope<"ROUND_RECAP", RoundRecapRes>;

export interface RoundFinishedRes {
  code: RoomCode;
  round_id: RoundId;
}
export type RoundFinishedMsg = WsEnvelope<"ROUND_FINISHED", RoundFinishedRes>;

/* ---------------------------------- */
/* State sync (Resync)                 */
/* ---------------------------------- */

export type GameStatus = "idle" | "vote" | "reveal_wait";

export interface StateSyncRes {
  code: RoomCode;
  phase: Phase;

  players: PlayerPublic[];
  senders: SenderPublic[];

  my_player_id: PlayerId | null;

  game: null | {
    current_round_id: RoundId | null;
    current_item_index: number | null;
    status: GameStatus;

    item: null | {
      round_id: RoundId;
      item_id: ItemId;
      reel: ReelPublic;
      k: number;
      senders_selectable: SenderSelectable[];
    };
  };

  scores: Record<PlayerId, number>;
}
export type StateSyncResponseMsg = WsEnvelope<"STATE_SYNC_RESPONSE", StateSyncRes>;

/* ---------------------------------- */
/* Game over                           */
/* ---------------------------------- */

export interface RankingEntry {
  player_id: PlayerId;
  score_total: number;
  rank: number; // 1..N (ties policy up to you)
}

export interface GameOverRes {
  code: RoomCode;
  ranking: RankingEntry[];
  scores: Record<PlayerId, number>;
}
export type GameOverMsg = WsEnvelope<"GAME_OVER", GameOverRes>;

/* ---------------------------------- */
/* Room closed                         */
/* ---------------------------------- */

export interface RoomClosedBroadcastRes {
  code: RoomCode;
  reason: "closed_by_master";
}
export type RoomClosedBroadcastMsg = WsEnvelope<
  "ROOM_CLOSED_BROADCAST",
  RoomClosedBroadcastRes
>;

/* ---------------------------------- */
/* Unions                              */
/* ---------------------------------- */

// Messages clients can send
export type ClientToServerMsg =
  | CreateRoomMsg
  | TogglePlayerMsg
  | StartGameMsg
  | ReelOpenedMsg
  | EndItemMsg
  | StartNextRoundMsg
  | RoomClosedMsg
  | JoinRoomMsg
  | TakePlayerMsg
  | RenamePlayerMsg
  | UpdateAvatarMsg
  | SubmitVoteMsg
  | StateSyncMsg;

// Messages server can send
export type ServerToClientMsg =
  | RoomCreatedMsg
  | JoinOkMsg
  | ErrorMsg
  | TakePlayerOkMsg
  | TakePlayerFailMsg
  | PlayerUpdateMsg
  | SlotInvalidatedMsg
  | GameStartMsg
  | NewItemMsg
  | StartVoteMsg
  | VoteAckMsg
  | PlayerVotedMsg
  | VoteResultsMsg
  | RoundRecapMsg
  | RoundFinishedMsg
  | StateSyncResponseMsg
  | GameOverMsg
  | RoomClosedBroadcastMsg;


04-redis-schema.md
Clés Redis + JSON exact + TTL + opérations par message.

05-sequence-diagrams.md
Diagrammes (Mermaid) lobby + game + resync + room close.

06-frontend-master.md
Pages Master (Lobby, Game) : états UI, events envoyés, handlers reçus.

07-frontend-play.md
Pages Play (Enter/Choose/Wait/Game) : états UI, events, handlers.
