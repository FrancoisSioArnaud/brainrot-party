# 03 — WS Protocol (Contrat messages) — v3

---

## 0) Règles générales

### Transport
WebSocket uniquement. Enveloppe :
- `type: string`
- `payload: object`

### Identité
- Play : `device_id`
- Master : `master_key` (secret)

### Autorité
- Serveur : claims, votes, scores, progression
- Master : reveal visuel, puis `END_ITEM`

---

## 1) Messages Lobby

### 1.1 `CREATE_ROOM` (Master → Serveur)
**Payload** : `CreateRoomReq`

**Réponse**
- `ROOM_CREATED {code, master_key, players_visible, senders_visible}`

---

### 1.2 `JOIN_ROOM` (Play → Serveur)
**Payload** : `{code, device_id}`

**Réponse**
- `JOIN_OK {phase, players_visible}`

**Erreurs**
- `ERROR room_not_found | room_expired`

---

### 1.3 `TAKE_PLAYER` (Play → Serveur)
**Payload** : `{code, player_id, device_id}`

**Réponses**
- `TAKE_PLAYER_OK`
- `TAKE_PLAYER_FAIL {reason}`
- broadcast `PLAYER_UPDATE` si OK

---

### 1.4 `RENAME_PLAYER` (Play → Serveur)
Lobby only, claim requis.
→ broadcast `PLAYER_UPDATE {player, sender_updated?}`

---

### 1.5 `UPDATE_AVATAR` (Play → Serveur)
Lobby only, claim requis.
→ broadcast `PLAYER_UPDATE`

---

### 1.6 `TOGGLE_PLAYER` (Master → Serveur)
**Payload** : `{code, master_key, player_id, active}`

Lobby only.
→ broadcast `PLAYER_UPDATE`  
si désactivation d’un pris → `SLOT_INVALIDATED` au Play concerné

---

### 1.7 `START_GAME` (Master → Serveur)
**Payload** : `{code, master_key}`

Réponse (push) :
- `GAME_START` à tous
- `NEW_ITEM` à tous

---

## 2) Messages Game

### 2.1 `NEW_ITEM` (Serveur → Tous)
Annonce l’item courant :
- `round_id, item_id, k, reel, senders_selectable`

---

### 2.2 `REEL_OPENED` (Master → Serveur)
**Payload** : `{code, master_key, round_id, item_id}`

Effets :
- `game.status=vote`
- `game.current_vote={round_id,item_id,expected_player_ids}`
- reset votes item
- init `game.votes_received_player_ids=[]`
- clear `game.current_vote_results=null`

Push :
- `START_VOTE {round_id,item_id,k,senders_selectable}` aux Plays

---

### 2.3 `SUBMIT_VOTE` (Play → Serveur)
**Payload** : `{code, round_id, item_id, player_id, device_id, selections}`

Réponses :
- `VOTE_ACK` au Play
- `PLAYER_VOTED` au Master
- si complet :
  - `VOTE_RESULTS` au Master (et stockage en Redis dans `game.current_vote_results`)
  - `game.status=reveal_wait`

---

### 2.4 `END_ITEM` (Master → Serveur)
**Payload** : `{code, master_key, round_id, item_id}`

Préconditions :
- `game.status=reveal_wait`
- `(round_id,item_id) == game.current_vote.(round_id,item_id)` strict

Push :
- si round continue : `NEW_ITEM`
- si round fini : `ROUND_RECAP` (Master) + `ROUND_FINISHED` (Plays) et `game.status=round_recap`

Nettoyage :
- `game.current_vote=null`
- `game.votes_received_player_ids=null`
- `game.current_vote_results=null`

---

### 2.5 `START_NEXT_ROUND` (Master → Serveur)
**Payload** : `{code, master_key}`

Préconditions :
- `game.status=round_recap`

Push :
- si next round : `NEW_ITEM`
- sinon : `GAME_OVER`

---

### 2.6 `GAME_OVER` (Serveur → Tous)
Classement final.

---

## 3) Resync / Close

### 3.1 `STATE_SYNC` (Client → Serveur)
**Payload**
- Play : `{code, device_id}`
- Master : `{code, device_id, master_key}`

**Réponse**
- `STATE_SYNC_RESPONSE`

**Erreurs**
- `ERROR room_not_found | room_expired`

---

### 3.2 `STATE_SYNC_RESPONSE` (Serveur → Client)
Toujours inclus :
- `phase`
- `players_visible`, `senders_visible`
- `scores`
- `my_player_id`
- `game` (si phase=game)

Inclus **seulement si master_key valide** :
- `players_all`, `senders_all`
- si `game.status=vote` : `game.votes_received_player_ids`
- si `game.status=reveal_wait` : `game.current_vote_results` (même contenu que `VOTE_RESULTS`, sans `code`)

---

### 3.3 `ROOM_CLOSED` (Master → Serveur)
**Payload** : `{code, master_key}`

Effet :
- suppression via SCAN/DEL de `room:{code}:*`

Push :
- `ROOM_CLOSED_BROADCAST` à tous
